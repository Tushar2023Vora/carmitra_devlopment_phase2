import React, { useLayoutEffect, useMemo, useRef, useState } from 'react';

const SWIPE_THRESHOLD = 24;
const CLICK_THRESHOLD = 5;

interface ItemPosition {
  start: number;
  end: number;
}

interface DragInfo {
  sx: number | null;
  sy: number | null;
  offset: number;
  translateX: number;
  currentIndex: number;
  didMove: boolean;
}

interface Params {
  spacing: number;
  childrenLength: number;
  paddingInlineStart: number;
  paddingInlineEnd: number;
}

export function useCarousel({ spacing, childrenLength, paddingInlineStart, paddingInlineEnd }: Params) {
  const carouselRef = useRef<HTMLDivElement>(null);
  const childrenRefs = useRef(Array.from({ length: childrenLength }, () => React.createRef<HTMLDivElement>()));

  const isDragging = useRef(false);
  const isScrolling = useRef(false);
  const animationFrame = useRef<number | null>(null);
  const drag = useRef<DragInfo>({
    sx: null,
    sy: null,
    offset: 0,
    translateX: 0,
    currentIndex: 0,
    didMove: false,
  });

  const [childWidths, setChildWidths] = useState<number[]>(() => childrenRefs.current.map(() => 0));
  const [isRTL, setIsRTL] = useState(false);

  const directionMultiplier = isRTL ? -1 : 1;
  const itemPositions: ItemPosition[] = useMemo(() => {
    let currentPosition = paddingInlineStart;
    return childWidths.map((width, i) => {
      const spacingOffset = i > 0 ? spacing : 0;
      const start = currentPosition - spacingOffset;
      const end = start - width;
      currentPosition = end;
      return { start, end };
    });
  }, [childWidths, spacing, paddingInlineStart]);

  const totalContentWidth = useMemo(() => {
    const totalItemWidth = childWidths.reduce((acc, width) => acc + width, 0);
    const totalSpacing = spacing * (childrenLength - 1);
    return totalItemWidth + totalSpacing;
  }, [childWidths, spacing, childrenLength]);

  useLayoutEffect(() => {
    if (carouselRef.current) {
      const dir = getComputedStyle(carouselRef.current).direction;
      setIsRTL(dir === 'rtl');
    }
  }, []);

  useLayoutEffect(() => {
    setChildWidths(childrenRefs.current.map((ref) => ref.current?.clientWidth ?? 0));
  }, [childrenLength]);

  useLayoutEffect(() => {
    if (itemPositions.length > 0) {
      drag.current.translateX = itemPositions[0].start;
      animate();
    }
  }, [itemPositions]);

  const dragStart = () => {
    if (!carouselRef.current) return;

    isDragging.current = true;
    carouselRef.current.style.cursor = 'grabbing';
    carouselRef.current.style.transition = 'none';

    animationFrame.current = requestAnimationFrame(animate);
  };
  const dragStop = () => {
    if (!carouselRef.current) return;

    isDragging.current = false;
    carouselRef.current.style.cursor = 'grab';
    carouselRef.current.style.transition = 'transform 0.5s ease';

    if (animationFrame.current) {
      cancelAnimationFrame(animationFrame.current);
      animationFrame.current = null;
    }
  };
  const dragRelease = () => {
    const { offset, currentIndex } = drag.current;

    const thresholdExceeded = Math.abs(offset) >= SWIPE_THRESHOLD;
    const swipeToNext = offset < 0 && currentIndex < childrenLength - 1;
    const swipeToPrev = offset > 0 && currentIndex > 0;

    let newIndex = currentIndex;
    if (thresholdExceeded && swipeToNext) {
      newIndex = currentIndex + 1;
    } else if (thresholdExceeded && swipeToPrev) {
      newIndex = currentIndex - 1;
    }

    function clampTranslateX(translateX: number) {
      const containerWidth = carouselRef.current?.clientWidth ?? 0;
      const start = paddingInlineStart;
      const end = Math.min(0, containerWidth - totalContentWidth) - paddingInlineEnd;

      return Math.min(start, Math.max(translateX, end));
    }

    drag.current.currentIndex = newIndex;
    drag.current.translateX = clampTranslateX(itemPositions[newIndex].start);
    drag.current.offset = 0;
  };

  const scrollStart = () => {
    isScrolling.current = true;
  };
  const scrollStop = () => {
    isScrolling.current = false;
  };

  const animate = () => {
    if (carouselRef.current) {
      const tx = (drag.current.translateX + drag.current.offset) * directionMultiplier;
      carouselRef.current.style.transform = `translateX(${tx}px)`;
    }
    if (animationFrame.current) {
      animationFrame.current = requestAnimationFrame(animate);
    }
  };

  const blockScroll = () => {
    if (carouselRef.current) {
      carouselRef.current.style.touchAction = 'pan-x';
    }
  };
  const unblockScroll = () => {
    if (carouselRef.current) {
      carouselRef.current.style.touchAction = 'pan-y';
    }
  };

  const onMouseDown = (event: React.MouseEvent<HTMLDivElement>) => {
    dragStart();
    scrollStop();

    drag.current.sx = event.clientX;
    drag.current.sy = event.clientY;
    drag.current.offset = 0;
    drag.current.didMove = false;
    animationFrame.current = requestAnimationFrame(animate);
  };

  const onMouseMove = (event: React.MouseEvent<HTMLDivElement>) => {
    if (!isDragging.current || drag.current.sx === null) return;
    drag.current.offset = (event.clientX - drag.current.sx) * directionMultiplier;
    if (Math.abs(drag.current.offset) > CLICK_THRESHOLD) {
      drag.current.didMove = true;
    }
  };

  const onMouseUp = (event: React.MouseEvent<HTMLDivElement>) => {
    if (!isDragging.current) return;
    scrollStop();
    dragRelease();
    dragStop();
    if (drag.current.didMove) {
      event.preventDefault();
      event.stopPropagation();
    }
  };

  const onMouseLeave = (event: React.MouseEvent<HTMLDivElement>) => {
    if (!isDragging.current) return;
    scrollStop();
    dragRelease();
    dragStop();
    if (drag.current.didMove) {
      event.preventDefault();
      event.stopPropagation();
    }
  };

  const onTouchStart = (event: React.TouchEvent<HTMLDivElement>) => {
    scrollStop();
    dragStop();

    const touch = event.touches[0];

    drag.current.sx = touch.clientX;
    drag.current.sy = touch.clientY;
    drag.current.offset = 0;
    drag.current.didMove = false;
    animationFrame.current = requestAnimationFrame(animate);
  };

  const onTouchMove = (event: React.TouchEvent<HTMLDivElement>) => {
    if (drag.current.sx === null || drag.current.sy === null || isScrolling.current) return;

    const { clientX, clientY } = event.touches[0];
    const { sx, sy } = drag.current;

    if (isDragging.current) {
      drag.current.offset = (clientX - sx) * directionMultiplier;
      if (Math.abs(drag.current.offset) > CLICK_THRESHOLD) {
        drag.current.didMove = true;
      }
      return;
    }

    const isVerticalScroll = Math.abs(clientY - sy) > Math.abs(clientX - sx);
    if (isVerticalScroll) {
      scrollStart();
    } else {
      drag.current.offset = (clientX - sx) * directionMultiplier;
      blockScroll();
      dragStart();
    }
  };

  const onTouchEnd = (event: React.TouchEvent<HTMLDivElement>) => {
    unblockScroll();
    scrollStop();
    dragRelease();
    dragStop();
    if (drag.current.didMove) {
      event.preventDefault();
      event.stopPropagation();
    }
  };

  const onClickCapture = (event: React.MouseEvent<HTMLDivElement>) => {
    if (drag.current.didMove) {
      event.preventDefault();
      event.stopPropagation();
    }
  };

  return {
    carouselRef,
    childrenRefs,
    handlers: {
      onMouseDown,
      onMouseMove,
      onMouseUp,
      onMouseLeave,
      onTouchStart,
      onTouchMove,
      onTouchEnd,
      onClickCapture,
    },
  };
}
