import React, { ReactElement } from 'react';

import {
  Box,
  FlexSizeSpecValue,
  type MessageTemplateProps,
  Text,
  TextButton,
  createRenderer,
  defaultProperties,
} from '@sendbird/uikit-message-template';

import { RMTCarousel } from '../components/RMTCarousel';
import { RMTImage } from '../components/RMTImage';
import { useHighlightStyle } from '../hook/useHighlightStyle';
import { type ReactParsedProperties, webkitLineClampStyles } from '../styles';
import { clx } from '../util';
import { ActionHandler } from './ActionHandler';

export const renderer = createRenderer<ReactParsedProperties>({
  views: {
    box(props) {
      const highlight = useHighlightStyle(props.rawProperties);
      return (
        <ActionHandler
          className={clx('sb-message-template__box', highlight.className)}
          inlineStyle={highlight.style}
          elementId={props.elementId}
          style={props.parsedProperties}
          props={props}
        >
          {props.children}
        </ActionHandler>
      );
    },
    text(props) {
      const highlight = useHighlightStyle(props.rawProperties);
      return (
        <ActionHandler
          className={clx('sb-message-template__text', highlight.className)}
          inlineStyle={highlight.style}
          elementId={props.elementId}
          style={props.parsedProperties}
          props={props}
        >
          {renderText(props, highlight.renderText)}
        </ActionHandler>
      );
    },
    image(props) {
      const highlight = useHighlightStyle(props.rawProperties);
      // todo: add image backup
      return (
        <ActionHandler
          className={clx('sb-message-template__image-container', highlight.className)}
          inlineStyle={highlight.style}
          elementId={props.elementId}
          style={props.parsedProperties}
          props={props}
        >
          <RMTImage
            className={'sb-message-template__image'}
            alt={'image'}
            src={props.imageUrl}
            style={{ width: '100%', height: '100%', aspectRatio: 'inherit', objectFit: 'inherit' }}
            tintColor={props.imageStyle?.tintColor}
            metaData={props.metaData}
          />
        </ActionHandler>
      );
    },
    textButton(props) {
      const highlight = useHighlightStyle(props.rawProperties);
      return (
        <ActionHandler
          className={clx('sb-message-template__text-button', highlight.className)}
          inlineStyle={highlight.style}
          elementId={props.elementId}
          style={props.parsedProperties}
          props={props}
        >
          {renderText({ maxTextLines: defaultProperties.textButton.maxTextLines, ...props }, highlight.renderText)}
        </ActionHandler>
      );
    },
    imageButton(props) {
      const highlight = useHighlightStyle(props.rawProperties);
      return (
        <ActionHandler
          className={clx(
            'sb-message-template__image-container',
            'sb-message-template__image-button',
            highlight.className,
          )}
          inlineStyle={highlight.style}
          elementId={props.elementId}
          style={props.parsedProperties}
          props={props}
        >
          <RMTImage
            className={'sb-message-template__image'}
            alt={'image-button'}
            src={props.imageUrl}
            style={{ width: '100%', height: '100%', aspectRatio: 'inherit', objectFit: 'inherit' }}
            tintColor={props.imageStyle?.tintColor}
            metaData={props.metaData}
          />
        </ActionHandler>
      );
    },
    carouselView(props) {
      const highlight = useHighlightStyle(props.rawProperties);
      return (
        <RMTCarousel
          className={clx('sb-message-template__carousel', highlight.className)}
          inlineStyle={highlight.style}
          maxChildWidth={props.carouselStyle?.maxChildWidth}
          spacing={props.carouselStyle?.spacing}
          style={props.parsedProperties}
        >
          {props.children as ReactElement<MessageTemplateProps>[]}
        </RMTCarousel>
      );
    },
  },
});

function convertNewlinesToBr(text: string, highlightText: (text: string) => React.ReactNode) {
  return text.split('\n').map((line, index) => (
    <React.Fragment key={index}>
      {highlightText(line)}
      <br />
    </React.Fragment>
  ));
}

function renderText(view: Text | TextButton, highlightText: (text: string) => React.ReactNode) {
  const { text, maxTextLines } = view;
  const isToBeWrapped = isFixedOrFill(view);
  const hasMaxLines = typeof maxTextLines === 'number' && maxTextLines > 0;

  const convertedText = convertNewlinesToBr(text, highlightText);

  if (hasMaxLines || isToBeWrapped) {
    const wrapperStyling = {
      ...((hasMaxLines || isToBeWrapped) && { maxWidth: '100%' }),
      ...(isToBeWrapped && { maxHeight: '100%', overflow: 'hidden' }),
    };
    return (
      <div style={wrapperStyling}>
        {hasMaxLines ? <div style={webkitLineClampStyles(maxTextLines)}>{convertedText}</div> : convertedText}
      </div>
    );
  }
  return hasMaxLines ? <div style={webkitLineClampStyles(maxTextLines)}>{convertedText}</div> : convertedText;
}

/**
 * Text that is fixed or fill parent should be wrapped in a div with max-width: 100% and max-height: 100%
 * This is to prevent text from overflowing the padding of the container
 */
function isFixedOrFill(view: Box | Text | TextButton) {
  const heightType = view?.height?.type;
  const widthType = view?.width?.type;
  const isFixedDimension = heightType === 'fixed' || widthType === 'fixed';
  const isFill =
    (heightType === 'flex' && view?.height?.value === FlexSizeSpecValue.FillParent) ||
    (widthType === 'flex' && view?.width?.value === FlexSizeSpecValue.FillParent);
  return isFixedDimension || isFill;
}
