import React from 'react';
import { FlexSizeSpecValue, createRenderer, defaultProperties, } from '@sendbird/uikit-message-template';
import { RMTCarousel } from '../components/RMTCarousel';
import { RMTImage } from '../components/RMTImage';
import { useHighlightStyle } from '../hook/useHighlightStyle';
import { webkitLineClampStyles } from '../styles';
import { clx } from '../util';
import { ActionHandler } from './ActionHandler';
export const renderer = createRenderer({
    views: {
        box(props) {
            const highlight = useHighlightStyle(props.rawProperties);
            return (React.createElement(ActionHandler, { className: clx('sb-message-template__box', highlight.className), inlineStyle: highlight.style, elementId: props.elementId, style: props.parsedProperties, props: props }, props.children));
        },
        text(props) {
            const highlight = useHighlightStyle(props.rawProperties);
            return (React.createElement(ActionHandler, { className: clx('sb-message-template__text', highlight.className), inlineStyle: highlight.style, elementId: props.elementId, style: props.parsedProperties, props: props }, renderText(props, highlight.renderText)));
        },
        image(props) {
            var _a;
            const highlight = useHighlightStyle(props.rawProperties);
            // todo: add image backup
            return (React.createElement(ActionHandler, { className: clx('sb-message-template__image-container', highlight.className), inlineStyle: highlight.style, elementId: props.elementId, style: props.parsedProperties, props: props },
                React.createElement(RMTImage, { className: 'sb-message-template__image', alt: 'image', src: props.imageUrl, style: { width: '100%', height: '100%', aspectRatio: 'inherit', objectFit: 'inherit' }, tintColor: (_a = props.imageStyle) === null || _a === void 0 ? void 0 : _a.tintColor, metaData: props.metaData })));
        },
        textButton(props) {
            const highlight = useHighlightStyle(props.rawProperties);
            return (React.createElement(ActionHandler, { className: clx('sb-message-template__text-button', highlight.className), inlineStyle: highlight.style, elementId: props.elementId, style: props.parsedProperties, props: props }, renderText(Object.assign({ maxTextLines: defaultProperties.textButton.maxTextLines }, props), highlight.renderText)));
        },
        imageButton(props) {
            var _a;
            const highlight = useHighlightStyle(props.rawProperties);
            return (React.createElement(ActionHandler, { className: clx('sb-message-template__image-container', 'sb-message-template__image-button', highlight.className), inlineStyle: highlight.style, elementId: props.elementId, style: props.parsedProperties, props: props },
                React.createElement(RMTImage, { className: 'sb-message-template__image', alt: 'image-button', src: props.imageUrl, style: { width: '100%', height: '100%', aspectRatio: 'inherit', objectFit: 'inherit' }, tintColor: (_a = props.imageStyle) === null || _a === void 0 ? void 0 : _a.tintColor, metaData: props.metaData })));
        },
        carouselView(props) {
            var _a, _b;
            const highlight = useHighlightStyle(props.rawProperties);
            return (React.createElement(RMTCarousel, { className: clx('sb-message-template__carousel', highlight.className), inlineStyle: highlight.style, maxChildWidth: (_a = props.carouselStyle) === null || _a === void 0 ? void 0 : _a.maxChildWidth, spacing: (_b = props.carouselStyle) === null || _b === void 0 ? void 0 : _b.spacing, style: props.parsedProperties }, props.children));
        },
    },
});
function convertNewlinesToBr(text, highlightText) {
    return text.split('\n').map((line, index) => (React.createElement(React.Fragment, { key: index },
        highlightText(line),
        React.createElement("br", null))));
}
function renderText(view, highlightText) {
    const { text, maxTextLines } = view;
    const isToBeWrapped = isFixedOrFill(view);
    const hasMaxLines = typeof maxTextLines === 'number' && maxTextLines > 0;
    const convertedText = convertNewlinesToBr(text, highlightText);
    if (hasMaxLines || isToBeWrapped) {
        const wrapperStyling = Object.assign(Object.assign({}, ((hasMaxLines || isToBeWrapped) && { maxWidth: '100%' })), (isToBeWrapped && { maxHeight: '100%', overflow: 'hidden' }));
        return (React.createElement("div", { style: wrapperStyling }, hasMaxLines ? React.createElement("div", { style: webkitLineClampStyles(maxTextLines) }, convertedText) : convertedText));
    }
    return hasMaxLines ? React.createElement("div", { style: webkitLineClampStyles(maxTextLines) }, convertedText) : convertedText;
}
/**
 * Text that is fixed or fill parent should be wrapped in a div with max-width: 100% and max-height: 100%
 * This is to prevent text from overflowing the padding of the container
 */
function isFixedOrFill(view) {
    var _a, _b, _c, _d;
    const heightType = (_a = view === null || view === void 0 ? void 0 : view.height) === null || _a === void 0 ? void 0 : _a.type;
    const widthType = (_b = view === null || view === void 0 ? void 0 : view.width) === null || _b === void 0 ? void 0 : _b.type;
    const isFixedDimension = heightType === 'fixed' || widthType === 'fixed';
    const isFill = (heightType === 'flex' && ((_c = view === null || view === void 0 ? void 0 : view.height) === null || _c === void 0 ? void 0 : _c.value) === FlexSizeSpecValue.FillParent) ||
        (widthType === 'flex' && ((_d = view === null || view === void 0 ? void 0 : view.width) === null || _d === void 0 ? void 0 : _d.value) === FlexSizeSpecValue.FillParent);
    return isFixedDimension || isFill;
}
